// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "cbase.h"
#include "gamerules.h"
#include "multiplay_gamerules.h"
#include "singleplay_gamerules.h"
#include "teamplay_gamerules.h"
#include "srcpy_gamerules.h"
#include "ammodef.h"
#include "items.h"
#include "hl2wars_gamerules.h"
#include "srcpy.h"
#include "tier0/memdbgon.h"
#include "CGameRules_pypp.hpp"

namespace bp = boost::python;

struct CGameRules_wrapper : CGameRules, bp::wrapper< CGameRules > {

    CGameRules_wrapper( )
    : CGameRules( )
      , bp::wrapper< CGameRules >(){
        // null constructor
    
    }

    virtual char const * AIClassText( int classType ) {
        PY_OVERRIDE_CHECK( CGameRules, AIClassText )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, AIClassText )
        bp::override func_AIClassText = this->get_override( "AIClassText" );
        if( func_AIClassText.ptr() != Py_None )
            try {
                return func_AIClassText( classType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AIClassText( classType );
            }
        else
            return this->CGameRules::AIClassText( classType );
    }
    
    char const * default_AIClassText( int classType ) {
        return CGameRules::AIClassText( classType );
    }

    virtual float AdjustPlayerDamageInflicted( float damage ) {
        PY_OVERRIDE_CHECK( CGameRules, AdjustPlayerDamageInflicted )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, AdjustPlayerDamageInflicted )
        bp::override func_AdjustPlayerDamageInflicted = this->get_override( "AdjustPlayerDamageInflicted" );
        if( func_AdjustPlayerDamageInflicted.ptr() != Py_None )
            try {
                return func_AdjustPlayerDamageInflicted( damage );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AdjustPlayerDamageInflicted( damage );
            }
        else
            return this->CGameRules::AdjustPlayerDamageInflicted( damage );
    }
    
    float default_AdjustPlayerDamageInflicted( float damage ) {
        return CGameRules::AdjustPlayerDamageInflicted( damage );
    }

    virtual void AdjustPlayerDamageTaken( ::CTakeDamageInfo * pInfo ) {
        PY_OVERRIDE_CHECK( CGameRules, AdjustPlayerDamageTaken )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, AdjustPlayerDamageTaken )
        bp::override func_AdjustPlayerDamageTaken = this->get_override( "AdjustPlayerDamageTaken" );
        if( func_AdjustPlayerDamageTaken.ptr() != Py_None )
            try {
                func_AdjustPlayerDamageTaken( boost::python::ptr(pInfo) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::AdjustPlayerDamageTaken( pInfo );
            }
        else
            this->CGameRules::AdjustPlayerDamageTaken( pInfo );
    }
    
    void default_AdjustPlayerDamageTaken( ::CTakeDamageInfo * pInfo ) {
        CGameRules::AdjustPlayerDamageTaken( pInfo );
    }

    virtual bool AllowAutoTargetCrosshair(  ) {
        PY_OVERRIDE_CHECK( CGameRules, AllowAutoTargetCrosshair )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, AllowAutoTargetCrosshair )
        bp::override func_AllowAutoTargetCrosshair = this->get_override( "AllowAutoTargetCrosshair" );
        if( func_AllowAutoTargetCrosshair.ptr() != Py_None )
            try {
                return func_AllowAutoTargetCrosshair(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AllowAutoTargetCrosshair(  );
            }
        else
            return this->CGameRules::AllowAutoTargetCrosshair(  );
    }
    
    bool default_AllowAutoTargetCrosshair(  ) {
        return CGameRules::AllowAutoTargetCrosshair( );
    }

    virtual bool AllowDamage( ::CBaseEntity * pVictim, ::CTakeDamageInfo const & info ){
        bp::override func_AllowDamage = this->get_override( "AllowDamage" );
        try {
            return func_AllowDamage( pVictim ? pVictim->GetPyHandle() : boost::python::object(), boost::ref(info) );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool AllowSoundscapes(  ) {
        PY_OVERRIDE_CHECK( CGameRules, AllowSoundscapes )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, AllowSoundscapes )
        bp::override func_AllowSoundscapes = this->get_override( "AllowSoundscapes" );
        if( func_AllowSoundscapes.ptr() != Py_None )
            try {
                return func_AllowSoundscapes(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::AllowSoundscapes(  );
            }
        else
            return this->CGameRules::AllowSoundscapes(  );
    }
    
    bool default_AllowSoundscapes(  ) {
        return CGameRules::AllowSoundscapes( );
    }

    virtual bool CanEntityBeUsePushed( ::CBaseEntity * pEnt ) {
        PY_OVERRIDE_CHECK( CGameRules, CanEntityBeUsePushed )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CanEntityBeUsePushed )
        bp::override func_CanEntityBeUsePushed = this->get_override( "CanEntityBeUsePushed" );
        if( func_CanEntityBeUsePushed.ptr() != Py_None )
            try {
                return func_CanEntityBeUsePushed( pEnt ? pEnt->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanEntityBeUsePushed( pEnt );
            }
        else
            return this->CGameRules::CanEntityBeUsePushed( pEnt );
    }
    
    bool default_CanEntityBeUsePushed( ::CBaseEntity * pEnt ) {
        return CGameRules::CanEntityBeUsePushed( pEnt );
    }

    virtual bool CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, int iAmmoIndex ) {
        PY_OVERRIDE_CHECK( CGameRules, CanHaveAmmo )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CanHaveAmmo )
        bp::override func_CanHaveAmmo = this->get_override( "CanHaveAmmo" );
        if( func_CanHaveAmmo.ptr() != Py_None )
            try {
                return func_CanHaveAmmo( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), iAmmoIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanHaveAmmo( pPlayer, iAmmoIndex );
            }
        else
            return this->CGameRules::CanHaveAmmo( pPlayer, iAmmoIndex );
    }
    
    bool default_CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, int iAmmoIndex ) {
        return CGameRules::CanHaveAmmo( pPlayer, iAmmoIndex );
    }

    virtual bool CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, char const * szName ) {
        PY_OVERRIDE_CHECK( CGameRules, CanHaveAmmo )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CanHaveAmmo )
        bp::override func_CanHaveAmmo = this->get_override( "CanHaveAmmo" );
        if( func_CanHaveAmmo.ptr() != Py_None )
            try {
                return func_CanHaveAmmo( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), szName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanHaveAmmo( pPlayer, szName );
            }
        else
            return this->CGameRules::CanHaveAmmo( pPlayer, szName );
    }
    
    bool default_CanHaveAmmo( ::CBaseCombatCharacter * pPlayer, char const * szName ) {
        return CGameRules::CanHaveAmmo( pPlayer, szName );
    }

    virtual bool CanHaveItem( ::CBasePlayer * pPlayer, ::CItem * pItem ){
        bp::override func_CanHaveItem = this->get_override( "CanHaveItem" );
        try {
            return func_CanHaveItem( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool CanHavePlayerItem( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        PY_OVERRIDE_CHECK( CGameRules, CanHavePlayerItem )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CanHavePlayerItem )
        bp::override func_CanHavePlayerItem = this->get_override( "CanHavePlayerItem" );
        if( func_CanHavePlayerItem.ptr() != Py_None )
            try {
                return func_CanHavePlayerItem( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::CanHavePlayerItem( pPlayer, pWeapon );
            }
        else
            return this->CGameRules::CanHavePlayerItem( pPlayer, pWeapon );
    }
    
    bool default_CanHavePlayerItem( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ) {
        return CGameRules::CanHavePlayerItem( pPlayer, pWeapon );
    }

    virtual void ChangePlayerTeam( ::CBasePlayer * pPlayer, char const * pTeamName, bool bKill, bool bGib ) {
        PY_OVERRIDE_CHECK( CGameRules, ChangePlayerTeam )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ChangePlayerTeam )
        bp::override func_ChangePlayerTeam = this->get_override( "ChangePlayerTeam" );
        if( func_ChangePlayerTeam.ptr() != Py_None )
            try {
                func_ChangePlayerTeam( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pTeamName, bKill, bGib );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ChangePlayerTeam( pPlayer, pTeamName, bKill, bGib );
            }
        else
            this->CGameRules::ChangePlayerTeam( pPlayer, pTeamName, bKill, bGib );
    }
    
    void default_ChangePlayerTeam( ::CBasePlayer * pPlayer, char const * pTeamName, bool bKill, bool bGib ) {
        CGameRules::ChangePlayerTeam( pPlayer, pTeamName, bKill, bGib );
    }

    virtual void CheckChatText( ::CBasePlayer * pPlayer, char * pText ) {
        PY_OVERRIDE_CHECK( CGameRules, CheckChatText )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CheckChatText )
        bp::override func_CheckChatText = this->get_override( "CheckChatText" );
        if( func_CheckChatText.ptr() != Py_None )
            try {
                func_CheckChatText( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pText );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CheckChatText( pPlayer, pText );
            }
        else
            this->CGameRules::CheckChatText( pPlayer, pText );
    }
    
    void default_CheckChatText( ::CBasePlayer * pPlayer, char * pText ) {
        CGameRules::CheckChatText( pPlayer, pText );
    }

    virtual bool ClientCommand( ::CBaseEntity * pEdict, ::CCommand const & args ) {
        PY_OVERRIDE_CHECK( CGameRules, ClientCommand )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ClientCommand )
        bp::override func_ClientCommand = this->get_override( "ClientCommand" );
        if( func_ClientCommand.ptr() != Py_None )
            try {
                return func_ClientCommand( pEdict ? pEdict->GetPyHandle() : boost::python::object(), boost::ref(args) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ClientCommand( pEdict, args );
            }
        else
            return this->CGameRules::ClientCommand( pEdict, args );
    }
    
    bool default_ClientCommand( ::CBaseEntity * pEdict, ::CCommand const & args ) {
        return CGameRules::ClientCommand( pEdict, args );
    }

    virtual void ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        PY_OVERRIDE_CHECK( CGameRules, ClientCommandKeyValues )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ClientCommandKeyValues )
        bp::override func_ClientCommandKeyValues = this->get_override( "ClientCommandKeyValues" );
        if( func_ClientCommandKeyValues.ptr() != Py_None )
            try {
                func_ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ClientCommandKeyValues( pEntity, pKeyValues );
            }
        else
            this->CGameRules::ClientCommandKeyValues( pEntity, pKeyValues );
    }
    
    void default_ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        CGameRules::ClientCommandKeyValues( pEntity, pKeyValues );
    }

    virtual bool ClientConnected( ::edict_t * pEntity, char const * pszName, char const * pszAddress, char * reject, int maxrejectlen ){
        bp::override func_ClientConnected = this->get_override( "ClientConnected" );
        try {
            return func_ClientConnected( boost::python::ptr(pEntity), pszName, pszAddress, reject, maxrejectlen );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void ClientDisconnected( ::edict_t * pClient ){
        bp::override func_ClientDisconnected = this->get_override( "ClientDisconnected" );
        try {
            func_ClientDisconnected( boost::python::ptr(pClient) );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void ClientSettingsChanged( ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, ClientSettingsChanged )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ClientSettingsChanged )
        bp::override func_ClientSettingsChanged = this->get_override( "ClientSettingsChanged" );
        if( func_ClientSettingsChanged.ptr() != Py_None )
            try {
                func_ClientSettingsChanged( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ClientSettingsChanged( pPlayer );
            }
        else
            this->CGameRules::ClientSettingsChanged( pPlayer );
    }
    
    void default_ClientSettingsChanged( ::CBasePlayer * pPlayer ) {
        CGameRules::ClientSettingsChanged( pPlayer );
    }

    virtual void CreateCustomNetworkStringTables(  ) {
        PY_OVERRIDE_CHECK( CGameRules, CreateCustomNetworkStringTables )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CreateCustomNetworkStringTables )
        bp::override func_CreateCustomNetworkStringTables = this->get_override( "CreateCustomNetworkStringTables" );
        if( func_CreateCustomNetworkStringTables.ptr() != Py_None )
            try {
                func_CreateCustomNetworkStringTables(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CreateCustomNetworkStringTables(  );
            }
        else
            this->CGameRules::CreateCustomNetworkStringTables(  );
    }
    
    void default_CreateCustomNetworkStringTables(  ) {
        CGameRules::CreateCustomNetworkStringTables( );
    }

    virtual void CreateStandardEntities(  ) {
        PY_OVERRIDE_CHECK( CGameRules, CreateStandardEntities )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, CreateStandardEntities )
        bp::override func_CreateStandardEntities = this->get_override( "CreateStandardEntities" );
        if( func_CreateStandardEntities.ptr() != Py_None )
            try {
                func_CreateStandardEntities(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::CreateStandardEntities(  );
            }
        else
            this->CGameRules::CreateStandardEntities(  );
    }
    
    void default_CreateStandardEntities(  ) {
        CGameRules::CreateStandardEntities( );
    }

    virtual int Damage_GetNoPhysicsForce(  ){
        bp::override func_Damage_GetNoPhysicsForce = this->get_override( "Damage_GetNoPhysicsForce" );
        try {
            return func_Damage_GetNoPhysicsForce(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int Damage_GetShouldGibCorpse(  ){
        bp::override func_Damage_GetShouldGibCorpse = this->get_override( "Damage_GetShouldGibCorpse" );
        try {
            return func_Damage_GetShouldGibCorpse(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int Damage_GetShouldNotBleed(  ){
        bp::override func_Damage_GetShouldNotBleed = this->get_override( "Damage_GetShouldNotBleed" );
        try {
            return func_Damage_GetShouldNotBleed(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int Damage_GetShowOnHud(  ){
        bp::override func_Damage_GetShowOnHud = this->get_override( "Damage_GetShowOnHud" );
        try {
            return func_Damage_GetShowOnHud(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int Damage_GetTimeBased(  ){
        bp::override func_Damage_GetTimeBased = this->get_override( "Damage_GetTimeBased" );
        try {
            return func_Damage_GetTimeBased(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool Damage_IsTimeBased( int iDmgType ){
        bp::override func_Damage_IsTimeBased = this->get_override( "Damage_IsTimeBased" );
        try {
            return func_Damage_IsTimeBased( iDmgType );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool Damage_NoPhysicsForce( int iDmgType ){
        bp::override func_Damage_NoPhysicsForce = this->get_override( "Damage_NoPhysicsForce" );
        try {
            return func_Damage_NoPhysicsForce( iDmgType );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool Damage_ShouldGibCorpse( int iDmgType ){
        bp::override func_Damage_ShouldGibCorpse = this->get_override( "Damage_ShouldGibCorpse" );
        try {
            return func_Damage_ShouldGibCorpse( iDmgType );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool Damage_ShouldNotBleed( int iDmgType ){
        bp::override func_Damage_ShouldNotBleed = this->get_override( "Damage_ShouldNotBleed" );
        try {
            return func_Damage_ShouldNotBleed( iDmgType );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool Damage_ShowOnHUD( int iDmgType ){
        bp::override func_Damage_ShowOnHUD = this->get_override( "Damage_ShowOnHUD" );
        try {
            return func_Damage_ShowOnHUD( iDmgType );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int DeadPlayerAmmo( ::CBasePlayer * pPlayer ){
        bp::override func_DeadPlayerAmmo = this->get_override( "DeadPlayerAmmo" );
        try {
            return func_DeadPlayerAmmo( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int DeadPlayerWeapons( ::CBasePlayer * pPlayer ){
        bp::override func_DeadPlayerWeapons = this->get_override( "DeadPlayerWeapons" );
        try {
            return func_DeadPlayerWeapons( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void DeathNotice( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ){
        bp::override func_DeathNotice = this->get_override( "DeathNotice" );
        try {
            func_DeathNotice( pVictim ? pVictim->GetPyHandle() : boost::python::object(), boost::ref(info) );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int DefaultFOV(  ) {
        PY_OVERRIDE_CHECK( CGameRules, DefaultFOV )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, DefaultFOV )
        bp::override func_DefaultFOV = this->get_override( "DefaultFOV" );
        if( func_DefaultFOV.ptr() != Py_None )
            try {
                return func_DefaultFOV(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::DefaultFOV(  );
            }
        else
            return this->CGameRules::DefaultFOV(  );
    }
    
    int default_DefaultFOV(  ) {
        return CGameRules::DefaultFOV( );
    }

    virtual void EndMultiplayerGame(  ) {
        PY_OVERRIDE_CHECK( CGameRules, EndMultiplayerGame )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, EndMultiplayerGame )
        bp::override func_EndMultiplayerGame = this->get_override( "EndMultiplayerGame" );
        if( func_EndMultiplayerGame.ptr() != Py_None )
            try {
                func_EndMultiplayerGame(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::EndMultiplayerGame(  );
            }
        else
            this->CGameRules::EndMultiplayerGame(  );
    }
    
    void default_EndMultiplayerGame(  ) {
        CGameRules::EndMultiplayerGame( );
    }

    virtual bool FAllowFlashlight(  ){
        bp::override func_FAllowFlashlight = this->get_override( "FAllowFlashlight" );
        try {
            return func_FAllowFlashlight(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool FAllowNPCs(  ){
        bp::override func_FAllowNPCs = this->get_override( "FAllowNPCs" );
        try {
            return func_FAllowNPCs(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool FPlayerCanRespawn( ::CBasePlayer * pPlayer ){
        bp::override func_FPlayerCanRespawn = this->get_override( "FPlayerCanRespawn" );
        try {
            return func_FPlayerCanRespawn( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool FPlayerCanTakeDamage( ::CBasePlayer * pPlayer, ::CBaseEntity * pAttacker ) {
        PY_OVERRIDE_CHECK( CGameRules, FPlayerCanTakeDamage )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, FPlayerCanTakeDamage )
        bp::override func_FPlayerCanTakeDamage = this->get_override( "FPlayerCanTakeDamage" );
        if( func_FPlayerCanTakeDamage.ptr() != Py_None )
            try {
                return func_FPlayerCanTakeDamage( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pAttacker ? pAttacker->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::FPlayerCanTakeDamage( pPlayer, pAttacker );
            }
        else
            return this->CGameRules::FPlayerCanTakeDamage( pPlayer, pAttacker );
    }
    
    bool default_FPlayerCanTakeDamage( ::CBasePlayer * pPlayer, ::CBaseEntity * pAttacker ) {
        return CGameRules::FPlayerCanTakeDamage( pPlayer, pAttacker );
    }

    virtual bool FShouldSwitchWeapon( ::CBasePlayer * pPlayer, ::CBaseCombatWeapon * pWeapon ){
        bp::override func_FShouldSwitchWeapon = this->get_override( "FShouldSwitchWeapon" );
        try {
            return func_FShouldSwitchWeapon( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float FlHEVChargerRechargeTime(  ) {
        PY_OVERRIDE_CHECK( CGameRules, FlHEVChargerRechargeTime )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, FlHEVChargerRechargeTime )
        bp::override func_FlHEVChargerRechargeTime = this->get_override( "FlHEVChargerRechargeTime" );
        if( func_FlHEVChargerRechargeTime.ptr() != Py_None )
            try {
                return func_FlHEVChargerRechargeTime(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::FlHEVChargerRechargeTime(  );
            }
        else
            return this->CGameRules::FlHEVChargerRechargeTime(  );
    }
    
    float default_FlHEVChargerRechargeTime(  ) {
        return CGameRules::FlHEVChargerRechargeTime( );
    }

    virtual float FlHealthChargerRechargeTime(  ){
        bp::override func_FlHealthChargerRechargeTime = this->get_override( "FlHealthChargerRechargeTime" );
        try {
            return func_FlHealthChargerRechargeTime(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float FlItemRespawnTime( ::CItem * pItem ){
        bp::override func_FlItemRespawnTime = this->get_override( "FlItemRespawnTime" );
        try {
            return func_FlItemRespawnTime( pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float FlPlayerFallDamage( ::CBasePlayer * pPlayer ){
        bp::override func_FlPlayerFallDamage = this->get_override( "FlPlayerFallDamage" );
        try {
            return func_FlPlayerFallDamage( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool FlPlayerFallDeathDoesScreenFade( ::CBasePlayer * pl ) {
        PY_OVERRIDE_CHECK( CGameRules, FlPlayerFallDeathDoesScreenFade )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, FlPlayerFallDeathDoesScreenFade )
        bp::override func_FlPlayerFallDeathDoesScreenFade = this->get_override( "FlPlayerFallDeathDoesScreenFade" );
        if( func_FlPlayerFallDeathDoesScreenFade.ptr() != Py_None )
            try {
                return func_FlPlayerFallDeathDoesScreenFade( pl ? pl->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::FlPlayerFallDeathDoesScreenFade( pl );
            }
        else
            return this->CGameRules::FlPlayerFallDeathDoesScreenFade( pl );
    }
    
    bool default_FlPlayerFallDeathDoesScreenFade( ::CBasePlayer * pl ) {
        return CGameRules::FlPlayerFallDeathDoesScreenFade( pl );
    }

    virtual float FlPlayerSpawnTime( ::CBasePlayer * pPlayer ){
        bp::override func_FlPlayerSpawnTime = this->get_override( "FlPlayerSpawnTime" );
        try {
            return func_FlPlayerSpawnTime( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float FlWeaponRespawnTime( ::CBaseCombatWeapon * pWeapon ){
        bp::override func_FlWeaponRespawnTime = this->get_override( "FlWeaponRespawnTime" );
        try {
            return func_FlWeaponRespawnTime( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float FlWeaponTryRespawn( ::CBaseCombatWeapon * pWeapon ){
        bp::override func_FlWeaponTryRespawn = this->get_override( "FlWeaponTryRespawn" );
        try {
            return func_FlWeaponTryRespawn( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float GetAmmoQuantityScale( int iAmmoIndex ) {
        PY_OVERRIDE_CHECK( CGameRules, GetAmmoQuantityScale )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetAmmoQuantityScale )
        bp::override func_GetAmmoQuantityScale = this->get_override( "GetAmmoQuantityScale" );
        if( func_GetAmmoQuantityScale.ptr() != Py_None )
            try {
                return func_GetAmmoQuantityScale( iAmmoIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAmmoQuantityScale( iAmmoIndex );
            }
        else
            return this->CGameRules::GetAmmoQuantityScale( iAmmoIndex );
    }
    
    float default_GetAmmoQuantityScale( int iAmmoIndex ) {
        return CGameRules::GetAmmoQuantityScale( iAmmoIndex );
    }

    virtual int GetAutoAimMode(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetAutoAimMode )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetAutoAimMode )
        bp::override func_GetAutoAimMode = this->get_override( "GetAutoAimMode" );
        if( func_GetAutoAimMode.ptr() != Py_None )
            try {
                return func_GetAutoAimMode(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAutoAimMode(  );
            }
        else
            return this->CGameRules::GetAutoAimMode(  );
    }
    
    int default_GetAutoAimMode(  ) {
        return CGameRules::GetAutoAimMode( );
    }

    virtual float GetAutoAimScale( ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, GetAutoAimScale )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetAutoAimScale )
        bp::override func_GetAutoAimScale = this->get_override( "GetAutoAimScale" );
        if( func_GetAutoAimScale.ptr() != Py_None )
            try {
                return func_GetAutoAimScale( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetAutoAimScale( pPlayer );
            }
        else
            return this->CGameRules::GetAutoAimScale( pPlayer );
    }
    
    float default_GetAutoAimScale( ::CBasePlayer * pPlayer ) {
        return CGameRules::GetAutoAimScale( pPlayer );
    }

    virtual char const * GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, GetChatFormat )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetChatFormat )
        bp::override func_GetChatFormat = this->get_override( "GetChatFormat" );
        if( func_GetChatFormat.ptr() != Py_None )
            try {
                return func_GetChatFormat( bTeamOnly, pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatFormat( bTeamOnly, pPlayer );
            }
        else
            return this->CGameRules::GetChatFormat( bTeamOnly, pPlayer );
    }
    
    char const * default_GetChatFormat( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatFormat( bTeamOnly, pPlayer );
    }

    virtual char const * GetChatLocation( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, GetChatLocation )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetChatLocation )
        bp::override func_GetChatLocation = this->get_override( "GetChatLocation" );
        if( func_GetChatLocation.ptr() != Py_None )
            try {
                return func_GetChatLocation( bTeamOnly, pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatLocation( bTeamOnly, pPlayer );
            }
        else
            return this->CGameRules::GetChatLocation( bTeamOnly, pPlayer );
    }
    
    char const * default_GetChatLocation( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatLocation( bTeamOnly, pPlayer );
    }

    virtual char const * GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, GetChatPrefix )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetChatPrefix )
        bp::override func_GetChatPrefix = this->get_override( "GetChatPrefix" );
        if( func_GetChatPrefix.ptr() != Py_None )
            try {
                return func_GetChatPrefix( bTeamOnly, pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetChatPrefix( bTeamOnly, pPlayer );
            }
        else
            return this->CGameRules::GetChatPrefix( bTeamOnly, pPlayer );
    }
    
    char const * default_GetChatPrefix( bool bTeamOnly, ::CBasePlayer * pPlayer ) {
        return CGameRules::GetChatPrefix( bTeamOnly, pPlayer );
    }

    virtual char const * GetDamageCustomString( ::CTakeDamageInfo const & info ) {
        PY_OVERRIDE_CHECK( CGameRules, GetDamageCustomString )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetDamageCustomString )
        bp::override func_GetDamageCustomString = this->get_override( "GetDamageCustomString" );
        if( func_GetDamageCustomString.ptr() != Py_None )
            try {
                return func_GetDamageCustomString( boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetDamageCustomString( info );
            }
        else
            return this->CGameRules::GetDamageCustomString( info );
    }
    
    char const * default_GetDamageCustomString( ::CTakeDamageInfo const & info ) {
        return CGameRules::GetDamageCustomString( info );
    }

    virtual float GetDamageMultiplier(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetDamageMultiplier )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetDamageMultiplier )
        bp::override func_GetDamageMultiplier = this->get_override( "GetDamageMultiplier" );
        if( func_GetDamageMultiplier.ptr() != Py_None )
            try {
                return func_GetDamageMultiplier(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetDamageMultiplier(  );
            }
        else
            return this->CGameRules::GetDamageMultiplier(  );
    }
    
    float default_GetDamageMultiplier(  ) {
        return CGameRules::GetDamageMultiplier( );
    }

    virtual char const * GetGameDescription(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetGameDescription )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetGameDescription )
        bp::override func_GetGameDescription = this->get_override( "GetGameDescription" );
        if( func_GetGameDescription.ptr() != Py_None )
            try {
                return func_GetGameDescription(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameDescription(  );
            }
        else
            return this->CGameRules::GetGameDescription(  );
    }
    
    char const * default_GetGameDescription(  ) {
        return CGameRules::GetGameDescription( );
    }

    virtual int GetGameType(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetGameType )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetGameType )
        bp::override func_GetGameType = this->get_override( "GetGameType" );
        if( func_GetGameType.ptr() != Py_None )
            try {
                return func_GetGameType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameType(  );
            }
        else
            return this->CGameRules::GetGameType(  );
    }
    
    int default_GetGameType(  ) {
        return CGameRules::GetGameType( );
    }

    virtual char const * GetGameTypeName(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetGameTypeName )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetGameTypeName )
        bp::override func_GetGameTypeName = this->get_override( "GetGameTypeName" );
        if( func_GetGameTypeName.ptr() != Py_None )
            try {
                return func_GetGameTypeName(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetGameTypeName(  );
            }
        else
            return this->CGameRules::GetGameTypeName(  );
    }
    
    char const * default_GetGameTypeName(  ) {
        return CGameRules::GetGameTypeName( );
    }

    virtual char const * GetIndexedTeamName( int teamIndex ) {
        PY_OVERRIDE_CHECK( CGameRules, GetIndexedTeamName )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetIndexedTeamName )
        bp::override func_GetIndexedTeamName = this->get_override( "GetIndexedTeamName" );
        if( func_GetIndexedTeamName.ptr() != Py_None )
            try {
                return func_GetIndexedTeamName( teamIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetIndexedTeamName( teamIndex );
            }
        else
            return this->CGameRules::GetIndexedTeamName( teamIndex );
    }
    
    char const * default_GetIndexedTeamName( int teamIndex ) {
        return CGameRules::GetIndexedTeamName( teamIndex );
    }

    virtual int GetMaxHumanPlayers(  ) const  {
        PY_OVERRIDE_CHECK( CGameRules, GetMaxHumanPlayers )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetMaxHumanPlayers )
        bp::override func_GetMaxHumanPlayers = this->get_override( "GetMaxHumanPlayers" );
        if( func_GetMaxHumanPlayers.ptr() != Py_None )
            try {
                return func_GetMaxHumanPlayers(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetMaxHumanPlayers(  );
            }
        else
            return this->CGameRules::GetMaxHumanPlayers(  );
    }
    
    int default_GetMaxHumanPlayers(  ) const  {
        return CGameRules::GetMaxHumanPlayers( );
    }

    virtual ::CBaseCombatWeapon * GetNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        PY_OVERRIDE_CHECK( CGameRules, GetNextBestWeapon )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetNextBestWeapon )
        bp::override func_GetNextBestWeapon = this->get_override( "GetNextBestWeapon" );
        if( func_GetNextBestWeapon.ptr() != Py_None )
            try {
                return func_GetNextBestWeapon( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pCurrentWeapon ? pCurrentWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
            }
        else
            return this->CGameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
    }
    
    ::CBaseCombatWeapon * default_GetNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        return CGameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
    }

    virtual ::CBaseEntity * GetPlayerSpawnSpot( ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, GetPlayerSpawnSpot )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetPlayerSpawnSpot )
        bp::override func_GetPlayerSpawnSpot = this->get_override( "GetPlayerSpawnSpot" );
        if( func_GetPlayerSpawnSpot.ptr() != Py_None )
            try {
                return func_GetPlayerSpawnSpot( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetPlayerSpawnSpot( pPlayer );
            }
        else
            return this->CGameRules::GetPlayerSpawnSpot( pPlayer );
    }
    
    ::CBaseEntity * default_GetPlayerSpawnSpot( ::CBasePlayer * pPlayer ) {
        return CGameRules::GetPlayerSpawnSpot( pPlayer );
    }

    virtual int GetSkillLevel(  ) {
        PY_OVERRIDE_CHECK( CGameRules, GetSkillLevel )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetSkillLevel )
        bp::override func_GetSkillLevel = this->get_override( "GetSkillLevel" );
        if( func_GetSkillLevel.ptr() != Py_None )
            try {
                return func_GetSkillLevel(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetSkillLevel(  );
            }
        else
            return this->CGameRules::GetSkillLevel(  );
    }
    
    int default_GetSkillLevel(  ) {
        return CGameRules::GetSkillLevel( );
    }

    virtual void GetTaggedConVarList( ::KeyValues * pCvarTagList ) {
        PY_OVERRIDE_CHECK( CGameRules, GetTaggedConVarList )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetTaggedConVarList )
        bp::override func_GetTaggedConVarList = this->get_override( "GetTaggedConVarList" );
        if( func_GetTaggedConVarList.ptr() != Py_None )
            try {
                func_GetTaggedConVarList( boost::python::ptr(pCvarTagList) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::GetTaggedConVarList( pCvarTagList );
            }
        else
            this->CGameRules::GetTaggedConVarList( pCvarTagList );
    }
    
    void default_GetTaggedConVarList( ::KeyValues * pCvarTagList ) {
        CGameRules::GetTaggedConVarList( pCvarTagList );
    }

    virtual char const * GetTeamID( ::CBaseEntity * pEntity ){
        bp::override func_GetTeamID = this->get_override( "GetTeamID" );
        try {
            return func_GetTeamID( pEntity ? pEntity->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int GetTeamIndex( char const * pTeamName ) {
        PY_OVERRIDE_CHECK( CGameRules, GetTeamIndex )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, GetTeamIndex )
        bp::override func_GetTeamIndex = this->get_override( "GetTeamIndex" );
        if( func_GetTeamIndex.ptr() != Py_None )
            try {
                return func_GetTeamIndex( pTeamName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::GetTeamIndex( pTeamName );
            }
        else
            return this->CGameRules::GetTeamIndex( pTeamName );
    }
    
    int default_GetTeamIndex( char const * pTeamName ) {
        return CGameRules::GetTeamIndex( pTeamName );
    }

    virtual int IPointsForKill( ::CBasePlayer * pAttacker, ::CBasePlayer * pKilled ){
        bp::override func_IPointsForKill = this->get_override( "IPointsForKill" );
        try {
            return func_IPointsForKill( pAttacker ? pAttacker->GetPyHandle() : boost::python::object(), pKilled ? pKilled->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool InRoundRestart(  ) {
        PY_OVERRIDE_CHECK( CGameRules, InRoundRestart )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, InRoundRestart )
        bp::override func_InRoundRestart = this->get_override( "InRoundRestart" );
        if( func_InRoundRestart.ptr() != Py_None )
            try {
                return func_InRoundRestart(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::InRoundRestart(  );
            }
        else
            return this->CGameRules::InRoundRestart(  );
    }
    
    bool default_InRoundRestart(  ) {
        return CGameRules::InRoundRestart( );
    }

    virtual bool Init(  ) {
        PY_OVERRIDE_CHECK( CGameRules, Init )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, Init )
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::Init(  );
            }
        else
            return this->CGameRules::Init(  );
    }
    
    bool default_Init(  ) {
        return CGameRules::Init( );
    }

    virtual void InitDefaultAIRelationships(  ) {
        PY_OVERRIDE_CHECK( CGameRules, InitDefaultAIRelationships )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, InitDefaultAIRelationships )
        bp::override func_InitDefaultAIRelationships = this->get_override( "InitDefaultAIRelationships" );
        if( func_InitDefaultAIRelationships.ptr() != Py_None )
            try {
                func_InitDefaultAIRelationships(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::InitDefaultAIRelationships(  );
            }
        else
            this->CGameRules::InitDefaultAIRelationships(  );
    }
    
    void default_InitDefaultAIRelationships(  ) {
        CGameRules::InitDefaultAIRelationships( );
    }

    virtual void InitGamerules(  ) {
        PY_OVERRIDE_CHECK( CGameRules, InitGamerules )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, InitGamerules )
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::InitGamerules(  );
            }
        else
            this->CGameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        CGameRules::InitGamerules( );
    }

    virtual void InitHUD( ::CBasePlayer * pl ){
        bp::override func_InitHUD = this->get_override( "InitHUD" );
        try {
            func_InitHUD( pl ? pl->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool IsAllowedToSpawn( ::CBaseEntity * pEntity ){
        bp::override func_IsAllowedToSpawn = this->get_override( "IsAllowedToSpawn" );
        try {
            return func_IsAllowedToSpawn( pEntity ? pEntity->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool IsCoOp(  ){
        bp::override func_IsCoOp = this->get_override( "IsCoOp" );
        try {
            return func_IsCoOp(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool IsDeathmatch(  ){
        bp::override func_IsDeathmatch = this->get_override( "IsDeathmatch" );
        try {
            return func_IsDeathmatch(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool IsMultiplayer(  ){
        bp::override func_IsMultiplayer = this->get_override( "IsMultiplayer" );
        try {
            return func_IsMultiplayer(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool IsSkillLevel( int iLevel ) {
        PY_OVERRIDE_CHECK( CGameRules, IsSkillLevel )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, IsSkillLevel )
        bp::override func_IsSkillLevel = this->get_override( "IsSkillLevel" );
        if( func_IsSkillLevel.ptr() != Py_None )
            try {
                return func_IsSkillLevel( iLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsSkillLevel( iLevel );
            }
        else
            return this->CGameRules::IsSkillLevel( iLevel );
    }
    
    bool default_IsSkillLevel( int iLevel ) {
        return CGameRules::IsSkillLevel( iLevel );
    }

    virtual bool IsSpawnPointValid( ::CBaseEntity * pSpot, ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, IsSpawnPointValid )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, IsSpawnPointValid )
        bp::override func_IsSpawnPointValid = this->get_override( "IsSpawnPointValid" );
        if( func_IsSpawnPointValid.ptr() != Py_None )
            try {
                return func_IsSpawnPointValid( pSpot ? pSpot->GetPyHandle() : boost::python::object(), pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsSpawnPointValid( pSpot, pPlayer );
            }
        else
            return this->CGameRules::IsSpawnPointValid( pSpot, pPlayer );
    }
    
    bool default_IsSpawnPointValid( ::CBaseEntity * pSpot, ::CBasePlayer * pPlayer ) {
        return CGameRules::IsSpawnPointValid( pSpot, pPlayer );
    }

    virtual bool IsTeamplay(  ) {
        PY_OVERRIDE_CHECK( CGameRules, IsTeamplay )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, IsTeamplay )
        bp::override func_IsTeamplay = this->get_override( "IsTeamplay" );
        if( func_IsTeamplay.ptr() != Py_None )
            try {
                return func_IsTeamplay(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsTeamplay(  );
            }
        else
            return this->CGameRules::IsTeamplay(  );
    }
    
    bool default_IsTeamplay(  ) {
        return CGameRules::IsTeamplay( );
    }

    virtual bool IsValidTeam( char const * pTeamName ) {
        PY_OVERRIDE_CHECK( CGameRules, IsValidTeam )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, IsValidTeam )
        bp::override func_IsValidTeam = this->get_override( "IsValidTeam" );
        if( func_IsValidTeam.ptr() != Py_None )
            try {
                return func_IsValidTeam( pTeamName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::IsValidTeam( pTeamName );
            }
        else
            return this->CGameRules::IsValidTeam( pTeamName );
    }
    
    bool default_IsValidTeam( char const * pTeamName ) {
        return CGameRules::IsValidTeam( pTeamName );
    }

    virtual int ItemShouldRespawn( ::CItem * pItem ){
        bp::override func_ItemShouldRespawn = this->get_override( "ItemShouldRespawn" );
        try {
            return func_ItemShouldRespawn( pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void LevelShutdown(  ) {
        PY_OVERRIDE_CHECK( CGameRules, LevelShutdown )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, LevelShutdown )
        bp::override func_LevelShutdown = this->get_override( "LevelShutdown" );
        if( func_LevelShutdown.ptr() != Py_None )
            try {
                func_LevelShutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::LevelShutdown(  );
            }
        else
            this->CGameRules::LevelShutdown(  );
    }
    
    void default_LevelShutdown(  ) {
        CGameRules::LevelShutdown( );
    }

    virtual void MarkAchievement( ::IRecipientFilter & filter, char const * pchAchievementName ) {
        PY_OVERRIDE_CHECK( CGameRules, MarkAchievement )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, MarkAchievement )
        bp::override func_MarkAchievement = this->get_override( "MarkAchievement" );
        if( func_MarkAchievement.ptr() != Py_None )
            try {
                func_MarkAchievement( boost::ref(filter), pchAchievementName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::MarkAchievement( filter, pchAchievementName );
            }
        else
            this->CGameRules::MarkAchievement( filter, pchAchievementName );
    }
    
    void default_MarkAchievement( ::IRecipientFilter & filter, char const * pchAchievementName ) {
        CGameRules::MarkAchievement( filter, pchAchievementName );
    }

    virtual char const * Name(  ) {
        PY_OVERRIDE_CHECK( CGameRules, Name )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, Name )
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::Name(  );
            }
        else
            return this->CGameRules::Name(  );
    }
    
    char const * default_Name(  ) {
        return CGameRules::Name( );
    }

    virtual int NumEntityClasses(  ) const  {
        PY_OVERRIDE_CHECK( CGameRules, NumEntityClasses )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, NumEntityClasses )
        bp::override func_NumEntityClasses = this->get_override( "NumEntityClasses" );
        if( func_NumEntityClasses.ptr() != Py_None )
            try {
                return func_NumEntityClasses(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::NumEntityClasses(  );
            }
        else
            return this->CGameRules::NumEntityClasses(  );
    }
    
    int default_NumEntityClasses(  ) const  {
        return CGameRules::NumEntityClasses( );
    }

    virtual int NumFactions(  ) const  {
        PY_OVERRIDE_CHECK( CGameRules, NumFactions )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, NumFactions )
        bp::override func_NumFactions = this->get_override( "NumFactions" );
        if( func_NumFactions.ptr() != Py_None )
            try {
                return func_NumFactions(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::NumFactions(  );
            }
        else
            return this->CGameRules::NumFactions(  );
    }
    
    int default_NumFactions(  ) const  {
        return CGameRules::NumFactions( );
    }

    virtual void OnBeginChangeLevel( char const * nextMapName, ::KeyValues * saveData ) {
        PY_OVERRIDE_CHECK( CGameRules, OnBeginChangeLevel )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, OnBeginChangeLevel )
        bp::override func_OnBeginChangeLevel = this->get_override( "OnBeginChangeLevel" );
        if( func_OnBeginChangeLevel.ptr() != Py_None )
            try {
                func_OnBeginChangeLevel( nextMapName, boost::python::ptr(saveData) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnBeginChangeLevel( nextMapName, saveData );
            }
        else
            this->CGameRules::OnBeginChangeLevel( nextMapName, saveData );
    }
    
    void default_OnBeginChangeLevel( char const * nextMapName, ::KeyValues * saveData ) {
        CGameRules::OnBeginChangeLevel( nextMapName, saveData );
    }

    virtual void OnNavMeshLoad(  ) {
        PY_OVERRIDE_CHECK( CGameRules, OnNavMeshLoad )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, OnNavMeshLoad )
        bp::override func_OnNavMeshLoad = this->get_override( "OnNavMeshLoad" );
        if( func_OnNavMeshLoad.ptr() != Py_None )
            try {
                func_OnNavMeshLoad(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnNavMeshLoad(  );
            }
        else
            this->CGameRules::OnNavMeshLoad(  );
    }
    
    void default_OnNavMeshLoad(  ) {
        CGameRules::OnNavMeshLoad( );
    }

    virtual void OnSkillLevelChanged( int iNewLevel ) {
        PY_OVERRIDE_CHECK( CGameRules, OnSkillLevelChanged )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, OnSkillLevelChanged )
        bp::override func_OnSkillLevelChanged = this->get_override( "OnSkillLevelChanged" );
        if( func_OnSkillLevelChanged.ptr() != Py_None )
            try {
                func_OnSkillLevelChanged( iNewLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::OnSkillLevelChanged( iNewLevel );
            }
        else
            this->CGameRules::OnSkillLevelChanged( iNewLevel );
    }
    
    void default_OnSkillLevelChanged( int iNewLevel ) {
        CGameRules::OnSkillLevelChanged( iNewLevel );
    }

    virtual bool PlayFootstepSounds( ::CBasePlayer * pl ) {
        PY_OVERRIDE_CHECK( CGameRules, PlayFootstepSounds )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, PlayFootstepSounds )
        bp::override func_PlayFootstepSounds = this->get_override( "PlayFootstepSounds" );
        if( func_PlayFootstepSounds.ptr() != Py_None )
            try {
                return func_PlayFootstepSounds( pl ? pl->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::PlayFootstepSounds( pl );
            }
        else
            return this->CGameRules::PlayFootstepSounds( pl );
    }
    
    bool default_PlayFootstepSounds( ::CBasePlayer * pl ) {
        return CGameRules::PlayFootstepSounds( pl );
    }

    virtual bool PlayTextureSounds(  ) {
        PY_OVERRIDE_CHECK( CGameRules, PlayTextureSounds )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, PlayTextureSounds )
        bp::override func_PlayTextureSounds = this->get_override( "PlayTextureSounds" );
        if( func_PlayTextureSounds.ptr() != Py_None )
            try {
                return func_PlayTextureSounds(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::PlayTextureSounds(  );
            }
        else
            return this->CGameRules::PlayTextureSounds(  );
    }
    
    bool default_PlayTextureSounds(  ) {
        return CGameRules::PlayTextureSounds( );
    }

    virtual bool PlayerCanHearChat( ::CBasePlayer * pListener, ::CBasePlayer * pSpeaker ){
        bp::override func_PlayerCanHearChat = this->get_override( "PlayerCanHearChat" );
        try {
            return func_PlayerCanHearChat( pListener ? pListener->GetPyHandle() : boost::python::object(), pSpeaker ? pSpeaker->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void PlayerGotAmmo( ::CBaseCombatCharacter * pPlayer, char * szName, int iCount ){
        bp::override func_PlayerGotAmmo = this->get_override( "PlayerGotAmmo" );
        try {
            func_PlayerGotAmmo( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), szName, iCount );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void PlayerGotItem( ::CBasePlayer * pPlayer, ::CItem * pItem ){
        bp::override func_PlayerGotItem = this->get_override( "PlayerGotItem" );
        try {
            func_PlayerGotItem( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void PlayerKilled( ::CBasePlayer * pVictim, ::CTakeDamageInfo const & info ){
        bp::override func_PlayerKilled = this->get_override( "PlayerKilled" );
        try {
            func_PlayerKilled( pVictim ? pVictim->GetPyHandle() : boost::python::object(), boost::ref(info) );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int PlayerRelationship( ::CBaseEntity * pPlayer, ::CBaseEntity * pTarget ){
        bp::override func_PlayerRelationship = this->get_override( "PlayerRelationship" );
        try {
            return func_PlayerRelationship( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pTarget ? pTarget->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void PlayerSpawn( ::CBasePlayer * pPlayer ){
        bp::override func_PlayerSpawn = this->get_override( "PlayerSpawn" );
        try {
            func_PlayerSpawn( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void PlayerThink( ::CBasePlayer * pPlayer ){
        bp::override func_PlayerThink = this->get_override( "PlayerThink" );
        try {
            func_PlayerThink( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void Precache(  ) {
        PY_OVERRIDE_CHECK( CGameRules, Precache )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, Precache )
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::Precache(  );
            }
        else
            this->CGameRules::Precache(  );
    }
    
    void default_Precache(  ) {
        CGameRules::Precache( );
    }

    virtual void RadiusDamage( ::CTakeDamageInfo const & info, ::Vector const & vecSrc, float flRadius, int iClassIgnore, ::CBaseEntity * pEntityIgnore ) {
        PY_OVERRIDE_CHECK( CGameRules, RadiusDamage )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, RadiusDamage )
        bp::override func_RadiusDamage = this->get_override( "RadiusDamage" );
        if( func_RadiusDamage.ptr() != Py_None )
            try {
                func_RadiusDamage( boost::ref(info), boost::ref(vecSrc), flRadius, iClassIgnore, pEntityIgnore ? pEntityIgnore->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::RadiusDamage( info, vecSrc, flRadius, iClassIgnore, pEntityIgnore );
            }
        else
            this->CGameRules::RadiusDamage( info, vecSrc, flRadius, iClassIgnore, pEntityIgnore );
    }
    
    void default_RadiusDamage( ::CTakeDamageInfo const & info, ::Vector const & vecSrc, float flRadius, int iClassIgnore, ::CBaseEntity * pEntityIgnore ) {
        CGameRules::RadiusDamage( info, vecSrc, flRadius, iClassIgnore, pEntityIgnore );
    }

    virtual void RefreshSkillData( bool forceUpdate ) {
        PY_OVERRIDE_CHECK( CGameRules, RefreshSkillData )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, RefreshSkillData )
        bp::override func_RefreshSkillData = this->get_override( "RefreshSkillData" );
        if( func_RefreshSkillData.ptr() != Py_None )
            try {
                func_RefreshSkillData( forceUpdate );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::RefreshSkillData( forceUpdate );
            }
        else
            this->CGameRules::RefreshSkillData( forceUpdate );
    }
    
    void default_RefreshSkillData( bool forceUpdate ) {
        CGameRules::RefreshSkillData( forceUpdate );
    }

    virtual void RegisterScriptFunctions(  ) {
        PY_OVERRIDE_CHECK( CGameRules, RegisterScriptFunctions )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, RegisterScriptFunctions )
        bp::override func_RegisterScriptFunctions = this->get_override( "RegisterScriptFunctions" );
        if( func_RegisterScriptFunctions.ptr() != Py_None )
            try {
                func_RegisterScriptFunctions(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::RegisterScriptFunctions(  );
            }
        else
            this->CGameRules::RegisterScriptFunctions(  );
    }
    
    void default_RegisterScriptFunctions(  ) {
        CGameRules::RegisterScriptFunctions( );
    }

    virtual void ResetMapCycleTimeStamp(  ) {
        PY_OVERRIDE_CHECK( CGameRules, ResetMapCycleTimeStamp )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ResetMapCycleTimeStamp )
        bp::override func_ResetMapCycleTimeStamp = this->get_override( "ResetMapCycleTimeStamp" );
        if( func_ResetMapCycleTimeStamp.ptr() != Py_None )
            try {
                func_ResetMapCycleTimeStamp(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ResetMapCycleTimeStamp(  );
            }
        else
            this->CGameRules::ResetMapCycleTimeStamp(  );
    }
    
    void default_ResetMapCycleTimeStamp(  ) {
        CGameRules::ResetMapCycleTimeStamp( );
    }

    virtual char const * SetDefaultPlayerTeam( ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, SetDefaultPlayerTeam )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, SetDefaultPlayerTeam )
        bp::override func_SetDefaultPlayerTeam = this->get_override( "SetDefaultPlayerTeam" );
        if( func_SetDefaultPlayerTeam.ptr() != Py_None )
            try {
                return func_SetDefaultPlayerTeam( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::SetDefaultPlayerTeam( pPlayer );
            }
        else
            return this->CGameRules::SetDefaultPlayerTeam( pPlayer );
    }
    
    char const * default_SetDefaultPlayerTeam( ::CBasePlayer * pPlayer ) {
        return CGameRules::SetDefaultPlayerTeam( pPlayer );
    }

    virtual void SetSkillLevel( int iLevel ) {
        PY_OVERRIDE_CHECK( CGameRules, SetSkillLevel )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, SetSkillLevel )
        bp::override func_SetSkillLevel = this->get_override( "SetSkillLevel" );
        if( func_SetSkillLevel.ptr() != Py_None )
            try {
                func_SetSkillLevel( iLevel );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::SetSkillLevel( iLevel );
            }
        else
            this->CGameRules::SetSkillLevel( iLevel );
    }
    
    void default_SetSkillLevel( int iLevel ) {
        CGameRules::SetSkillLevel( iLevel );
    }

    virtual bool ShouldAutoAim( ::CBasePlayer * pPlayer, ::edict_t * target ) {
        PY_OVERRIDE_CHECK( CGameRules, ShouldAutoAim )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ShouldAutoAim )
        bp::override func_ShouldAutoAim = this->get_override( "ShouldAutoAim" );
        if( func_ShouldAutoAim.ptr() != Py_None )
            try {
                return func_ShouldAutoAim( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), boost::python::ptr(target) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldAutoAim( pPlayer, target );
            }
        else
            return this->CGameRules::ShouldAutoAim( pPlayer, target );
    }
    
    bool default_ShouldAutoAim( ::CBasePlayer * pPlayer, ::edict_t * target ) {
        return CGameRules::ShouldAutoAim( pPlayer, target );
    }

    virtual bool ShouldBurningPropsEmitLight(  ) {
        PY_OVERRIDE_CHECK( CGameRules, ShouldBurningPropsEmitLight )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ShouldBurningPropsEmitLight )
        bp::override func_ShouldBurningPropsEmitLight = this->get_override( "ShouldBurningPropsEmitLight" );
        if( func_ShouldBurningPropsEmitLight.ptr() != Py_None )
            try {
                return func_ShouldBurningPropsEmitLight(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldBurningPropsEmitLight(  );
            }
        else
            return this->CGameRules::ShouldBurningPropsEmitLight(  );
    }
    
    bool default_ShouldBurningPropsEmitLight(  ) {
        return CGameRules::ShouldBurningPropsEmitLight( );
    }

    virtual bool ShouldTimeoutClient( int nUserID, float flTimeSinceLastReceived ) {
        PY_OVERRIDE_CHECK( CGameRules, ShouldTimeoutClient )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ShouldTimeoutClient )
        bp::override func_ShouldTimeoutClient = this->get_override( "ShouldTimeoutClient" );
        if( func_ShouldTimeoutClient.ptr() != Py_None )
            try {
                return func_ShouldTimeoutClient( nUserID, flTimeSinceLastReceived );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldTimeoutClient( nUserID, flTimeSinceLastReceived );
            }
        else
            return this->CGameRules::ShouldTimeoutClient( nUserID, flTimeSinceLastReceived );
    }
    
    bool default_ShouldTimeoutClient( int nUserID, float flTimeSinceLastReceived ) {
        return CGameRules::ShouldTimeoutClient( nUserID, flTimeSinceLastReceived );
    }

    virtual bool ShouldUseRobustRadiusDamage( ::CBaseEntity * pEntity ) {
        PY_OVERRIDE_CHECK( CGameRules, ShouldUseRobustRadiusDamage )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ShouldUseRobustRadiusDamage )
        bp::override func_ShouldUseRobustRadiusDamage = this->get_override( "ShouldUseRobustRadiusDamage" );
        if( func_ShouldUseRobustRadiusDamage.ptr() != Py_None )
            try {
                return func_ShouldUseRobustRadiusDamage( pEntity ? pEntity->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::ShouldUseRobustRadiusDamage( pEntity );
            }
        else
            return this->CGameRules::ShouldUseRobustRadiusDamage( pEntity );
    }
    
    bool default_ShouldUseRobustRadiusDamage( ::CBaseEntity * pEntity ) {
        return CGameRules::ShouldUseRobustRadiusDamage( pEntity );
    }

    virtual void ShutdownGamerules(  ) {
        PY_OVERRIDE_CHECK( CGameRules, ShutdownGamerules )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, ShutdownGamerules )
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::ShutdownGamerules(  );
            }
        else
            this->CGameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        CGameRules::ShutdownGamerules( );
    }

    virtual bool SwitchToNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        PY_OVERRIDE_CHECK( CGameRules, SwitchToNextBestWeapon )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, SwitchToNextBestWeapon )
        bp::override func_SwitchToNextBestWeapon = this->get_override( "SwitchToNextBestWeapon" );
        if( func_SwitchToNextBestWeapon.ptr() != Py_None )
            try {
                return func_SwitchToNextBestWeapon( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pCurrentWeapon ? pCurrentWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
            }
        else
            return this->CGameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
    }
    
    bool default_SwitchToNextBestWeapon( ::CBaseCombatCharacter * pPlayer, ::CBaseCombatWeapon * pCurrentWeapon ) {
        return CGameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
    }

    virtual void Think(  ){
        bp::override func_Think = this->get_override( "Think" );
        try {
            func_Think(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void UpdateClientData( ::CBasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( CGameRules, UpdateClientData )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, UpdateClientData )
        bp::override func_UpdateClientData = this->get_override( "UpdateClientData" );
        if( func_UpdateClientData.ptr() != Py_None )
            try {
                func_UpdateClientData( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::UpdateClientData( pPlayer );
            }
        else
            this->CGameRules::UpdateClientData( pPlayer );
    }
    
    void default_UpdateClientData( ::CBasePlayer * pPlayer ) {
        CGameRules::UpdateClientData( pPlayer );
    }

    virtual void UpdateGameplayStatsFromSteam(  ) {
        PY_OVERRIDE_CHECK( CGameRules, UpdateGameplayStatsFromSteam )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, UpdateGameplayStatsFromSteam )
        bp::override func_UpdateGameplayStatsFromSteam = this->get_override( "UpdateGameplayStatsFromSteam" );
        if( func_UpdateGameplayStatsFromSteam.ptr() != Py_None )
            try {
                func_UpdateGameplayStatsFromSteam(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CGameRules::UpdateGameplayStatsFromSteam(  );
            }
        else
            this->CGameRules::UpdateGameplayStatsFromSteam(  );
    }
    
    void default_UpdateGameplayStatsFromSteam(  ) {
        CGameRules::UpdateGameplayStatsFromSteam( );
    }

    virtual ::QAngle VecItemRespawnAngles( ::CItem * pItem ){
        bp::override func_VecItemRespawnAngles = this->get_override( "VecItemRespawnAngles" );
        try {
            return func_VecItemRespawnAngles( pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual ::Vector VecItemRespawnSpot( ::CItem * pItem ){
        bp::override func_VecItemRespawnSpot = this->get_override( "VecItemRespawnSpot" );
        try {
            return func_VecItemRespawnSpot( pItem ? pItem->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual ::Vector VecWeaponRespawnSpot( ::CBaseCombatWeapon * pWeapon ){
        bp::override func_VecWeaponRespawnSpot = this->get_override( "VecWeaponRespawnSpot" );
        try {
            return func_VecWeaponRespawnSpot( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int WeaponShouldRespawn( ::CBaseCombatWeapon * pWeapon ){
        bp::override func_WeaponShouldRespawn = this->get_override( "WeaponShouldRespawn" );
        try {
            return func_WeaponShouldRespawn( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float WeaponTraceEntity( ::CBaseEntity * pEntity, ::Vector const & vecStart, ::Vector const & vecEnd, unsigned int mask, ::trace_t * ptr ) {
        PY_OVERRIDE_CHECK( CGameRules, WeaponTraceEntity )
        PY_OVERRIDE_LOG( _gamerules, CGameRules, WeaponTraceEntity )
        bp::override func_WeaponTraceEntity = this->get_override( "WeaponTraceEntity" );
        if( func_WeaponTraceEntity.ptr() != Py_None )
            try {
                return func_WeaponTraceEntity( pEntity ? pEntity->GetPyHandle() : boost::python::object(), boost::ref(vecStart), boost::ref(vecEnd), mask, boost::python::ptr(ptr) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CGameRules::WeaponTraceEntity( pEntity, vecStart, vecEnd, mask, ptr );
            }
        else
            return this->CGameRules::WeaponTraceEntity( pEntity, vecStart, vecEnd, mask, ptr );
    }
    
    float default_WeaponTraceEntity( ::CBaseEntity * pEntity, ::Vector const & vecStart, ::Vector const & vecEnd, unsigned int mask, ::trace_t * ptr ) {
        return CGameRules::WeaponTraceEntity( pEntity, vecStart, vecEnd, mask, ptr );
    }

};

void register_CGameRules_class(){

    bp::class_< CGameRules_wrapper, boost::noncopyable >( "CGameRules", bp::no_init )    
        .def( bp::init< >() )    
        .def( 
            "AIClassText"
            , (char const * ( ::CGameRules::* )( int ) )(&::CGameRules::AIClassText)
            , (char const * ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_AIClassText)
            , ( bp::arg("classType") ) )    
        .def( 
            "AdjustPlayerDamageInflicted"
            , (float ( ::CGameRules::* )( float ) )(&::CGameRules::AdjustPlayerDamageInflicted)
            , (float ( CGameRules_wrapper::* )( float ) )(&CGameRules_wrapper::default_AdjustPlayerDamageInflicted)
            , ( bp::arg("damage") ) )    
        .def( 
            "AdjustPlayerDamageTaken"
            , (void ( ::CGameRules::* )( ::CTakeDamageInfo * ) )(&::CGameRules::AdjustPlayerDamageTaken)
            , (void ( CGameRules_wrapper::* )( ::CTakeDamageInfo * ) )(&CGameRules_wrapper::default_AdjustPlayerDamageTaken)
            , ( bp::arg("pInfo") ) )    
        .def( 
            "AllowAutoTargetCrosshair"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::AllowAutoTargetCrosshair)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_AllowAutoTargetCrosshair) )    
        .def( 
            "AllowDamage"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBaseEntity *,::CTakeDamageInfo const & ) )(&::CGameRules::AllowDamage) )
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "AllowSoundscapes"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::AllowSoundscapes)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_AllowSoundscapes) )    
        .def( 
            "CanEntityBeUsePushed"
            , (bool ( ::CGameRules::* )( ::CBaseEntity * ) )(&::CGameRules::CanEntityBeUsePushed)
            , (bool ( CGameRules_wrapper::* )( ::CBaseEntity * ) )(&CGameRules_wrapper::default_CanEntityBeUsePushed)
            , ( bp::arg("pEnt") ) )    
        .def( 
            "CanHaveAmmo"
            , (bool ( ::CGameRules::* )( ::CBaseCombatCharacter *,int ) )(&::CGameRules::CanHaveAmmo)
            , (bool ( CGameRules_wrapper::* )( ::CBaseCombatCharacter *,int ) )(&CGameRules_wrapper::default_CanHaveAmmo)
            , ( bp::arg("pPlayer"), bp::arg("iAmmoIndex") ) )    
        .def( 
            "CanHaveAmmo"
            , (bool ( ::CGameRules::* )( ::CBaseCombatCharacter *,char const * ) )(&::CGameRules::CanHaveAmmo)
            , (bool ( CGameRules_wrapper::* )( ::CBaseCombatCharacter *,char const * ) )(&CGameRules_wrapper::default_CanHaveAmmo)
            , ( bp::arg("pPlayer"), bp::arg("szName") ) )    
        .def( 
            "CanHaveItem"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBasePlayer *,::CItem * ) )(&::CGameRules::CanHaveItem) )
            , ( bp::arg("pPlayer"), bp::arg("pItem") ) )    
        .def( 
            "CanHavePlayerItem"
            , (bool ( ::CGameRules::* )( ::CBasePlayer *,::CBaseCombatWeapon * ) )(&::CGameRules::CanHavePlayerItem)
            , (bool ( CGameRules_wrapper::* )( ::CBasePlayer *,::CBaseCombatWeapon * ) )(&CGameRules_wrapper::default_CanHavePlayerItem)
            , ( bp::arg("pPlayer"), bp::arg("pWeapon") ) )    
        .def( 
            "ChangePlayerTeam"
            , (void ( ::CGameRules::* )( ::CBasePlayer *,char const *,bool,bool ) )(&::CGameRules::ChangePlayerTeam)
            , (void ( CGameRules_wrapper::* )( ::CBasePlayer *,char const *,bool,bool ) )(&CGameRules_wrapper::default_ChangePlayerTeam)
            , ( bp::arg("pPlayer"), bp::arg("pTeamName"), bp::arg("bKill"), bp::arg("bGib") ) )    
        .def( 
            "CheckChatText"
            , (void ( ::CGameRules::* )( ::CBasePlayer *,char * ) )(&::CGameRules::CheckChatText)
            , (void ( CGameRules_wrapper::* )( ::CBasePlayer *,char * ) )(&CGameRules_wrapper::default_CheckChatText)
            , ( bp::arg("pPlayer"), bp::arg("pText") ) )    
        .def( 
            "ClientCommand"
            , (bool ( ::CGameRules::* )( ::CBaseEntity *,::CCommand const & ) )(&::CGameRules::ClientCommand)
            , (bool ( CGameRules_wrapper::* )( ::CBaseEntity *,::CCommand const & ) )(&CGameRules_wrapper::default_ClientCommand)
            , ( bp::arg("pEdict"), bp::arg("args") ) )    
        .def( 
            "ClientCommandKeyValues"
            , (void ( ::CGameRules::* )( ::edict_t *,::KeyValues * ) )(&::CGameRules::ClientCommandKeyValues)
            , (void ( CGameRules_wrapper::* )( ::edict_t *,::KeyValues * ) )(&CGameRules_wrapper::default_ClientCommandKeyValues)
            , ( bp::arg("pEntity"), bp::arg("pKeyValues") ) )    
        .def( 
            "ClientConnected"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::edict_t *,char const *,char const *,char *,int ) )(&::CGameRules::ClientConnected) )
            , ( bp::arg("pEntity"), bp::arg("pszName"), bp::arg("pszAddress"), bp::arg("reject"), bp::arg("maxrejectlen") ) )    
        .def( 
            "ClientDisconnected"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::edict_t * ) )(&::CGameRules::ClientDisconnected) )
            , ( bp::arg("pClient") ) )    
        .def( 
            "ClientSettingsChanged"
            , (void ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::ClientSettingsChanged)
            , (void ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_ClientSettingsChanged)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "CreateCustomNetworkStringTables"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::CreateCustomNetworkStringTables)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_CreateCustomNetworkStringTables) )    
        .def( 
            "CreateStandardEntities"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::CreateStandardEntities)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_CreateStandardEntities) )    
        .def( 
            "Damage_GetNoPhysicsForce"
            , bp::pure_virtual( (int ( ::CGameRules::* )(  ) )(&::CGameRules::Damage_GetNoPhysicsForce) ) )    
        .def( 
            "Damage_GetShouldGibCorpse"
            , bp::pure_virtual( (int ( ::CGameRules::* )(  ) )(&::CGameRules::Damage_GetShouldGibCorpse) ) )    
        .def( 
            "Damage_GetShouldNotBleed"
            , bp::pure_virtual( (int ( ::CGameRules::* )(  ) )(&::CGameRules::Damage_GetShouldNotBleed) ) )    
        .def( 
            "Damage_GetShowOnHud"
            , bp::pure_virtual( (int ( ::CGameRules::* )(  ) )(&::CGameRules::Damage_GetShowOnHud) ) )    
        .def( 
            "Damage_GetTimeBased"
            , bp::pure_virtual( (int ( ::CGameRules::* )(  ) )(&::CGameRules::Damage_GetTimeBased) ) )    
        .def( 
            "Damage_IsTimeBased"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( int ) )(&::CGameRules::Damage_IsTimeBased) )
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_NoPhysicsForce"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( int ) )(&::CGameRules::Damage_NoPhysicsForce) )
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldGibCorpse"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( int ) )(&::CGameRules::Damage_ShouldGibCorpse) )
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldNotBleed"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( int ) )(&::CGameRules::Damage_ShouldNotBleed) )
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShowOnHUD"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( int ) )(&::CGameRules::Damage_ShowOnHUD) )
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "DeadPlayerAmmo"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::DeadPlayerAmmo) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "DeadPlayerWeapons"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::DeadPlayerWeapons) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "DeathNotice"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer *,::CTakeDamageInfo const & ) )(&::CGameRules::DeathNotice) )
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "DefaultFOV"
            , (int ( ::CGameRules::* )(  ) )(&::CGameRules::DefaultFOV)
            , (int ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_DefaultFOV) )    
        .def( 
            "EndGameFrame"
            , (void ( ::CGameRules::* )(  ) )( &::CGameRules::EndGameFrame ) )    
        .def( 
            "EndMultiplayerGame"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::EndMultiplayerGame)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_EndMultiplayerGame) )    
        .def( 
            "FAllowFlashlight"
            , bp::pure_virtual( (bool ( ::CGameRules::* )(  ) )(&::CGameRules::FAllowFlashlight) ) )    
        .def( 
            "FAllowNPCs"
            , bp::pure_virtual( (bool ( ::CGameRules::* )(  ) )(&::CGameRules::FAllowNPCs) ) )    
        .def( 
            "FPlayerCanRespawn"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::FPlayerCanRespawn) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "FPlayerCanTakeDamage"
            , (bool ( ::CGameRules::* )( ::CBasePlayer *,::CBaseEntity * ) )(&::CGameRules::FPlayerCanTakeDamage)
            , (bool ( CGameRules_wrapper::* )( ::CBasePlayer *,::CBaseEntity * ) )(&CGameRules_wrapper::default_FPlayerCanTakeDamage)
            , ( bp::arg("pPlayer"), bp::arg("pAttacker") ) )    
        .def( 
            "FShouldSwitchWeapon"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBasePlayer *,::CBaseCombatWeapon * ) )(&::CGameRules::FShouldSwitchWeapon) )
            , ( bp::arg("pPlayer"), bp::arg("pWeapon") ) )    
        .def( 
            "FlHEVChargerRechargeTime"
            , (float ( ::CGameRules::* )(  ) )(&::CGameRules::FlHEVChargerRechargeTime)
            , (float ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_FlHEVChargerRechargeTime) )    
        .def( 
            "FlHealthChargerRechargeTime"
            , bp::pure_virtual( (float ( ::CGameRules::* )(  ) )(&::CGameRules::FlHealthChargerRechargeTime) ) )    
        .def( 
            "FlItemRespawnTime"
            , bp::pure_virtual( (float ( ::CGameRules::* )( ::CItem * ) )(&::CGameRules::FlItemRespawnTime) )
            , ( bp::arg("pItem") ) )    
        .def( 
            "FlPlayerFallDamage"
            , bp::pure_virtual( (float ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::FlPlayerFallDamage) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "FlPlayerFallDeathDoesScreenFade"
            , (bool ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::FlPlayerFallDeathDoesScreenFade)
            , (bool ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_FlPlayerFallDeathDoesScreenFade)
            , ( bp::arg("pl") ) )    
        .def( 
            "FlPlayerSpawnTime"
            , bp::pure_virtual( (float ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::FlPlayerSpawnTime) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "FlWeaponRespawnTime"
            , bp::pure_virtual( (float ( ::CGameRules::* )( ::CBaseCombatWeapon * ) )(&::CGameRules::FlWeaponRespawnTime) )
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "FlWeaponTryRespawn"
            , bp::pure_virtual( (float ( ::CGameRules::* )( ::CBaseCombatWeapon * ) )(&::CGameRules::FlWeaponTryRespawn) )
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "ForceSplitScreenPlayersOnToSameTeam"
            , (bool ( ::CGameRules::* )(  ) )( &::CGameRules::ForceSplitScreenPlayersOnToSameTeam ) )    
        .def( 
            "FrameUpdatePostEntityThink"
            , (void ( ::CGameRules::* )(  ) )( &::CGameRules::FrameUpdatePostEntityThink ) )    
        .def( 
            "GetAmmoDamage"
            , (float ( ::CGameRules::* )( ::CBaseEntity *,::CBaseEntity *,int ) )( &::CGameRules::GetAmmoDamage )
            , ( bp::arg("pAttacker"), bp::arg("pVictim"), bp::arg("nAmmoType") ) )    
        .def( 
            "GetAmmoQuantityScale"
            , (float ( ::CGameRules::* )( int ) )(&::CGameRules::GetAmmoQuantityScale)
            , (float ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_GetAmmoQuantityScale)
            , ( bp::arg("iAmmoIndex") ) )    
        .def( 
            "GetAutoAimMode"
            , (int ( ::CGameRules::* )(  ) )(&::CGameRules::GetAutoAimMode)
            , (int ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetAutoAimMode) )    
        .def( 
            "GetAutoAimScale"
            , (float ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::GetAutoAimScale)
            , (float ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_GetAutoAimScale)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "GetChatFormat"
            , (char const * ( ::CGameRules::* )( bool,::CBasePlayer * ) )(&::CGameRules::GetChatFormat)
            , (char const * ( CGameRules_wrapper::* )( bool,::CBasePlayer * ) )(&CGameRules_wrapper::default_GetChatFormat)
            , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) )    
        .def( 
            "GetChatLocation"
            , (char const * ( ::CGameRules::* )( bool,::CBasePlayer * ) )(&::CGameRules::GetChatLocation)
            , (char const * ( CGameRules_wrapper::* )( bool,::CBasePlayer * ) )(&CGameRules_wrapper::default_GetChatLocation)
            , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) )    
        .def( 
            "GetChatPrefix"
            , (char const * ( ::CGameRules::* )( bool,::CBasePlayer * ) )(&::CGameRules::GetChatPrefix)
            , (char const * ( CGameRules_wrapper::* )( bool,::CBasePlayer * ) )(&CGameRules_wrapper::default_GetChatPrefix)
            , ( bp::arg("bTeamOnly"), bp::arg("pPlayer") ) )    
        .def( 
            "GetDamageCustomString"
            , (char const * ( ::CGameRules::* )( ::CTakeDamageInfo const & ) )(&::CGameRules::GetDamageCustomString)
            , (char const * ( CGameRules_wrapper::* )( ::CTakeDamageInfo const & ) )(&CGameRules_wrapper::default_GetDamageCustomString)
            , ( bp::arg("info") ) )    
        .def( 
            "GetDamageMultiplier"
            , (float ( ::CGameRules::* )(  ) )(&::CGameRules::GetDamageMultiplier)
            , (float ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetDamageMultiplier) )    
        .def( 
            "GetGameDescription"
            , (char const * ( ::CGameRules::* )(  ) )(&::CGameRules::GetGameDescription)
            , (char const * ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetGameDescription) )    
        .def( 
            "GetGameType"
            , (int ( ::CGameRules::* )(  ) )(&::CGameRules::GetGameType)
            , (int ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetGameType) )    
        .def( 
            "GetGameTypeName"
            , (char const * ( ::CGameRules::* )(  ) )(&::CGameRules::GetGameTypeName)
            , (char const * ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetGameTypeName) )    
        .def( 
            "GetIndexedTeamName"
            , (char const * ( ::CGameRules::* )( int ) )(&::CGameRules::GetIndexedTeamName)
            , (char const * ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_GetIndexedTeamName)
            , ( bp::arg("teamIndex") ) )    
        .def( 
            "GetMaxHumanPlayers"
            , (int ( ::CGameRules::* )(  ) const)(&::CGameRules::GetMaxHumanPlayers)
            , (int ( CGameRules_wrapper::* )(  ) const)(&CGameRules_wrapper::default_GetMaxHumanPlayers) )    
        .def( 
            "GetNextBestWeapon"
            , (::CBaseCombatWeapon * ( ::CGameRules::* )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) )(&::CGameRules::GetNextBestWeapon)
            , (::CBaseCombatWeapon * ( CGameRules_wrapper::* )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) )(&CGameRules_wrapper::default_GetNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetPlayerSpawnSpot"
            , (::CBaseEntity * ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::GetPlayerSpawnSpot)
            , (::CBaseEntity * ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_GetPlayerSpawnSpot)
            , ( bp::arg("pPlayer") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetSkillLevel"
            , (int ( ::CGameRules::* )(  ) )(&::CGameRules::GetSkillLevel)
            , (int ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_GetSkillLevel) )    
        .def( 
            "GetTaggedConVarList"
            , (void ( ::CGameRules::* )( ::KeyValues * ) )(&::CGameRules::GetTaggedConVarList)
            , (void ( CGameRules_wrapper::* )( ::KeyValues * ) )(&CGameRules_wrapper::default_GetTaggedConVarList)
            , ( bp::arg("pCvarTagList") ) )    
        .def( 
            "GetTeamID"
            , bp::pure_virtual( (char const * ( ::CGameRules::* )( ::CBaseEntity * ) )(&::CGameRules::GetTeamID) )
            , ( bp::arg("pEntity") ) )    
        .def( 
            "GetTeamIndex"
            , (int ( ::CGameRules::* )( char const * ) )(&::CGameRules::GetTeamIndex)
            , (int ( CGameRules_wrapper::* )( char const * ) )(&CGameRules_wrapper::default_GetTeamIndex)
            , ( bp::arg("pTeamName") ) )    
        .def( 
            "GetTopDownMovementAxis"
            , (::QAngle const & ( ::CGameRules::* )(  ) )(&::CGameRules::GetTopDownMovementAxis)
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "IPointsForKill"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CBasePlayer *,::CBasePlayer * ) )(&::CGameRules::IPointsForKill) )
            , ( bp::arg("pAttacker"), bp::arg("pKilled") ) )    
        .def( 
            "InRoundRestart"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::InRoundRestart)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_InRoundRestart) )    
        .def( 
            "Init"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::Init)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_Init) )    
        .def( 
            "InitDefaultAIRelationships"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::InitDefaultAIRelationships)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_InitDefaultAIRelationships) )    
        .def( 
            "InitGamerules"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::InitGamerules)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_InitGamerules) )    
        .def( 
            "InitHUD"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::InitHUD) )
            , ( bp::arg("pl") ) )    
        .def( 
            "IsAllowedToSpawn"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBaseEntity * ) )(&::CGameRules::IsAllowedToSpawn) )
            , ( bp::arg("pEntity") ) )    
        .def( 
            "IsCoOp"
            , bp::pure_virtual( (bool ( ::CGameRules::* )(  ) )(&::CGameRules::IsCoOp) ) )    
        .def( 
            "IsDeathmatch"
            , bp::pure_virtual( (bool ( ::CGameRules::* )(  ) )(&::CGameRules::IsDeathmatch) ) )    
        .def( 
            "IsMultiplayer"
            , bp::pure_virtual( (bool ( ::CGameRules::* )(  ) )(&::CGameRules::IsMultiplayer) ) )    
        .def( 
            "IsSkillLevel"
            , (bool ( ::CGameRules::* )( int ) )(&::CGameRules::IsSkillLevel)
            , (bool ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_IsSkillLevel)
            , ( bp::arg("iLevel") ) )    
        .def( 
            "IsSpawnPointValid"
            , (bool ( ::CGameRules::* )( ::CBaseEntity *,::CBasePlayer * ) )(&::CGameRules::IsSpawnPointValid)
            , (bool ( CGameRules_wrapper::* )( ::CBaseEntity *,::CBasePlayer * ) )(&CGameRules_wrapper::default_IsSpawnPointValid)
            , ( bp::arg("pSpot"), bp::arg("pPlayer") ) )    
        .def( 
            "IsTeamplay"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::IsTeamplay)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_IsTeamplay) )    
        .def( 
            "IsTopDown"
            , (bool ( ::CGameRules::* )(  ) )( &::CGameRules::IsTopDown ) )    
        .def( 
            "IsValidTeam"
            , (bool ( ::CGameRules::* )( char const * ) )(&::CGameRules::IsValidTeam)
            , (bool ( CGameRules_wrapper::* )( char const * ) )(&CGameRules_wrapper::default_IsValidTeam)
            , ( bp::arg("pTeamName") ) )    
        .def( 
            "ItemShouldRespawn"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CItem * ) )(&::CGameRules::ItemShouldRespawn) )
            , ( bp::arg("pItem") ) )    
        .def( 
            "LevelShutdown"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::LevelShutdown)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_LevelShutdown) )    
        .def( 
            "MarkAchievement"
            , (void ( ::CGameRules::* )( ::IRecipientFilter &,char const * ) )(&::CGameRules::MarkAchievement)
            , (void ( CGameRules_wrapper::* )( ::IRecipientFilter &,char const * ) )(&CGameRules_wrapper::default_MarkAchievement)
            , ( bp::arg("filter"), bp::arg("pchAchievementName") ) )    
        .def( 
            "Name"
            , (char const * ( ::CGameRules::* )(  ) )(&::CGameRules::Name)
            , (char const * ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_Name) )    
        .def( 
            "NetworkStateChanged"
            , (void ( ::CGameRules::* )(  ) )( &::CGameRules::NetworkStateChanged ) )    
        .def( 
            "NetworkStateChanged"
            , (void ( ::CGameRules::* )( void * ) )( &::CGameRules::NetworkStateChanged )
            , ( bp::arg("pVar") ) )    
        .def( 
            "NumEntityClasses"
            , (int ( ::CGameRules::* )(  ) const)(&::CGameRules::NumEntityClasses)
            , (int ( CGameRules_wrapper::* )(  ) const)(&CGameRules_wrapper::default_NumEntityClasses) )    
        .def( 
            "NumFactions"
            , (int ( ::CGameRules::* )(  ) const)(&::CGameRules::NumFactions)
            , (int ( CGameRules_wrapper::* )(  ) const)(&CGameRules_wrapper::default_NumFactions) )    
        .def( 
            "OnBeginChangeLevel"
            , (void ( ::CGameRules::* )( char const *,::KeyValues * ) )(&::CGameRules::OnBeginChangeLevel)
            , (void ( CGameRules_wrapper::* )( char const *,::KeyValues * ) )(&CGameRules_wrapper::default_OnBeginChangeLevel)
            , ( bp::arg("nextMapName"), bp::arg("saveData") ) )    
        .def( 
            "OnNavMeshLoad"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::OnNavMeshLoad)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_OnNavMeshLoad) )    
        .def( 
            "OnSkillLevelChanged"
            , (void ( ::CGameRules::* )( int ) )(&::CGameRules::OnSkillLevelChanged)
            , (void ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_OnSkillLevelChanged)
            , ( bp::arg("iNewLevel") ) )    
        .def( 
            "PlayFootstepSounds"
            , (bool ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::PlayFootstepSounds)
            , (bool ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_PlayFootstepSounds)
            , ( bp::arg("pl") ) )    
        .def( 
            "PlayTextureSounds"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::PlayTextureSounds)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_PlayTextureSounds) )    
        .def( 
            "PlayerCanHearChat"
            , bp::pure_virtual( (bool ( ::CGameRules::* )( ::CBasePlayer *,::CBasePlayer * ) )(&::CGameRules::PlayerCanHearChat) )
            , ( bp::arg("pListener"), bp::arg("pSpeaker") ) )    
        .def( 
            "PlayerGotAmmo"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBaseCombatCharacter *,char *,int ) )(&::CGameRules::PlayerGotAmmo) )
            , ( bp::arg("pPlayer"), bp::arg("szName"), bp::arg("iCount") ) )    
        .def( 
            "PlayerGotItem"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer *,::CItem * ) )(&::CGameRules::PlayerGotItem) )
            , ( bp::arg("pPlayer"), bp::arg("pItem") ) )    
        .def( 
            "PlayerKilled"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer *,::CTakeDamageInfo const & ) )(&::CGameRules::PlayerKilled) )
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "PlayerRelationship"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CBaseEntity *,::CBaseEntity * ) )(&::CGameRules::PlayerRelationship) )
            , ( bp::arg("pPlayer"), bp::arg("pTarget") ) )    
        .def( 
            "PlayerSpawn"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::PlayerSpawn) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "PlayerThink"
            , bp::pure_virtual( (void ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::PlayerThink) )
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "Precache"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::Precache)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_Precache) )    
        .def( 
            "RadiusDamage"
            , (void ( ::CGameRules::* )( ::CTakeDamageInfo const &,::Vector const &,float,int,::CBaseEntity * ) )(&::CGameRules::RadiusDamage)
            , (void ( CGameRules_wrapper::* )( ::CTakeDamageInfo const &,::Vector const &,float,int,::CBaseEntity * ) )(&CGameRules_wrapper::default_RadiusDamage)
            , ( bp::arg("info"), bp::arg("vecSrc"), bp::arg("flRadius"), bp::arg("iClassIgnore"), bp::arg("pEntityIgnore") ) )    
        .def( 
            "RefreshSkillData"
            , (void ( ::CGameRules::* )( bool ) )(&::CGameRules::RefreshSkillData)
            , (void ( CGameRules_wrapper::* )( bool ) )(&CGameRules_wrapper::default_RefreshSkillData)
            , ( bp::arg("forceUpdate") ) )    
        .def( 
            "RegisterScriptFunctions"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::RegisterScriptFunctions)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_RegisterScriptFunctions) )    
        .def( 
            "ResetMapCycleTimeStamp"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::ResetMapCycleTimeStamp)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_ResetMapCycleTimeStamp) )    
        .def( 
            "SetDefaultPlayerTeam"
            , (char const * ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::SetDefaultPlayerTeam)
            , (char const * ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_SetDefaultPlayerTeam)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "SetSkillLevel"
            , (void ( ::CGameRules::* )( int ) )(&::CGameRules::SetSkillLevel)
            , (void ( CGameRules_wrapper::* )( int ) )(&CGameRules_wrapper::default_SetSkillLevel)
            , ( bp::arg("iLevel") ) )    
        .def( 
            "ShouldAutoAim"
            , (bool ( ::CGameRules::* )( ::CBasePlayer *,::edict_t * ) )(&::CGameRules::ShouldAutoAim)
            , (bool ( CGameRules_wrapper::* )( ::CBasePlayer *,::edict_t * ) )(&CGameRules_wrapper::default_ShouldAutoAim)
            , ( bp::arg("pPlayer"), bp::arg("target") ) )    
        .def( 
            "ShouldBurningPropsEmitLight"
            , (bool ( ::CGameRules::* )(  ) )(&::CGameRules::ShouldBurningPropsEmitLight)
            , (bool ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_ShouldBurningPropsEmitLight) )    
        .def( 
            "ShouldCollide"
            , (bool ( ::CGameRules::* )( int,int ) )( &::CGameRules::ShouldCollide )
            , ( bp::arg("collisionGroup0"), bp::arg("collisionGroup1") ) )    
        .def( 
            "ShouldTimeoutClient"
            , (bool ( ::CGameRules::* )( int,float ) )(&::CGameRules::ShouldTimeoutClient)
            , (bool ( CGameRules_wrapper::* )( int,float ) )(&CGameRules_wrapper::default_ShouldTimeoutClient)
            , ( bp::arg("nUserID"), bp::arg("flTimeSinceLastReceived") ) )    
        .def( 
            "ShouldUseRobustRadiusDamage"
            , (bool ( ::CGameRules::* )( ::CBaseEntity * ) )(&::CGameRules::ShouldUseRobustRadiusDamage)
            , (bool ( CGameRules_wrapper::* )( ::CBaseEntity * ) )(&CGameRules_wrapper::default_ShouldUseRobustRadiusDamage)
            , ( bp::arg("pEntity") ) )    
        .def( 
            "ShutdownGamerules"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::ShutdownGamerules)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_ShutdownGamerules) )    
        .def( 
            "SwitchToNextBestWeapon"
            , (bool ( ::CGameRules::* )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) )(&::CGameRules::SwitchToNextBestWeapon)
            , (bool ( CGameRules_wrapper::* )( ::CBaseCombatCharacter *,::CBaseCombatWeapon * ) )(&CGameRules_wrapper::default_SwitchToNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") ) )    
        .def( 
            "Think"
            , bp::pure_virtual( (void ( ::CGameRules::* )(  ) )(&::CGameRules::Think) ) )    
        .def( 
            "UpdateClientData"
            , (void ( ::CGameRules::* )( ::CBasePlayer * ) )(&::CGameRules::UpdateClientData)
            , (void ( CGameRules_wrapper::* )( ::CBasePlayer * ) )(&CGameRules_wrapper::default_UpdateClientData)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "UpdateGameplayStatsFromSteam"
            , (void ( ::CGameRules::* )(  ) )(&::CGameRules::UpdateGameplayStatsFromSteam)
            , (void ( CGameRules_wrapper::* )(  ) )(&CGameRules_wrapper::default_UpdateGameplayStatsFromSteam) )    
        .def( 
            "VecItemRespawnAngles"
            , bp::pure_virtual( (::QAngle ( ::CGameRules::* )( ::CItem * ) )(&::CGameRules::VecItemRespawnAngles) )
            , ( bp::arg("pItem") ) )    
        .def( 
            "VecItemRespawnSpot"
            , bp::pure_virtual( (::Vector ( ::CGameRules::* )( ::CItem * ) )(&::CGameRules::VecItemRespawnSpot) )
            , ( bp::arg("pItem") ) )    
        .def( 
            "VecWeaponRespawnSpot"
            , bp::pure_virtual( (::Vector ( ::CGameRules::* )( ::CBaseCombatWeapon * ) )(&::CGameRules::VecWeaponRespawnSpot) )
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "WeaponShouldRespawn"
            , bp::pure_virtual( (int ( ::CGameRules::* )( ::CBaseCombatWeapon * ) )(&::CGameRules::WeaponShouldRespawn) )
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "WeaponTraceEntity"
            , (float ( ::CGameRules::* )( ::CBaseEntity *,::Vector const &,::Vector const &,unsigned int,::trace_t * ) )(&::CGameRules::WeaponTraceEntity)
            , (float ( CGameRules_wrapper::* )( ::CBaseEntity *,::Vector const &,::Vector const &,unsigned int,::trace_t * ) )(&CGameRules_wrapper::default_WeaponTraceEntity)
            , ( bp::arg("pEntity"), bp::arg("vecStart"), bp::arg("vecEnd"), bp::arg("mask"), bp::arg("ptr") ) );

}

